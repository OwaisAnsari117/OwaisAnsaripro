class Solution {
public:
    int optimalSearchTree(int keys[], int freq[], int n) {
        int cost[101][101]; // as per constraints (n â‰¤ 100)
        
        // Base case: single key
        for (int i = 0; i < n; i++) {
            cost[i][i] = freq[i];
        }
        
        // l = chain length
        for (int l = 2; l <= n; l++) {
            for (int i = 0; i <= n - l; i++) {
                int j = i + l - 1;
                cost[i][j] = INT_MAX;
                
                // sum of freq[i..j]
                int sum = 0;
                for (int k = i; k <= j; k++)
                    sum += freq[k];
                
                // Try each key as root
                for (int r = i; r <= j; r++) {
                    int left = (r > i) ? cost[i][r - 1] : 0;
                    int right = (r < j) ? cost[r + 1][j] : 0;
                    int val = left + right + sum;
                    if (val < cost[i][j])
                        cost[i][j] = val;    
        }
        return cost[0][n - 1];
    }
};
